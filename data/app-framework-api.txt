AI Service Layer API
For pricing information, please refer to Domo’s online consumption terms (https://www.domo.com/consumption-terms) and the credit rate card in your Domo instance (Admin > Company Settings > Credit Utilization > Rate Card) for more information.
Domo's AI Service Layer enables developers to build AI capabilities into their Domo Apps. In particular, the AI Service Layer currently supports two services from within Apps:
Text Generation
Text-to-SQL
Image-to-Text
Domo allows you to configure which models power each of the services. For more on how that works, see this video.
You can also see example usage of the the Text Generation and the Text-to-SQL in the AI Domo Bricks currently available to download for free in the Domo AppStore.
AI ChatGPT Brick
ChatGPT Dataset Description Brick
ChatGPT Text-To-SQL Query Brick
Text Generation
Generates a text response from a text prompt.
Code Example
The body variable in this post request is an example of a sample request body.
const prompt = 'Tell me a joke about data.';
const body = {
  input: prompt,
};
domo
  .post(`/domo/ai/v1/text/generation`, body)
  .then((response) => console.log(response));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
input String Required The prompt you are sending to the model
promptTemplate Object Optional An override for the prompt template used in the service. It has one property template, which expects a string.
parameters Object Optional Used with the promptTemplate for additional customization. You can pass any key, value pair of strings. See examples below.
model String Optional The id of the model you'd like to use if you don't want to use the default model.
HTTP Request
POST /domo/ai/v1/text/generation HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The only required field in the request body is the input string, but you can provide additional properties in the request body to futher customize the text generation service. If you choose to use the promptTemplate property to override the default prompt template, you'll need to use ${input} into the template string to pass through the input of your prompt.
{
  "input": "Recap the 2021 superbowl",
  "promptTemplate": {
    "template": "${input}. You are a helpful assistant that gives answers in ${max_words} words or less"
  },
  "parameters": {
    "max_words": "30"
  },
  "model": "8dc5737d-0bc8-425b-ad0d-5d6ec1a99e72"
}
HTTP Response
Returns the prompt used and the responses from the model. If the a model was specified in the request, then modelId will return the model and isCustomerModel will be true.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "prompt": "Recap the 2021 superbowl",
    "choices": [
      {
        "output": "The 2021 Super Bowl, also known as Super Bowl LV, took place on February 7, 2021 and James Stadium ..."
      }
    ],
    "modelId": "8dc5737d-0bc8-425b-ad0d-5d6ec1a99e72",
    "isCustomerModel": true
}
Text-to-SQL
Generates a SQL query based on a prompt and a DataSet's schema.
Code Example
The body variable in this post request is an example of a sample request body.
const exampleDataSourceSchema = {
  dataSourceName: 'Sales',
  description: 'Sales Data',
  columns: [
    {
      name: 'Date',
      type: 'date',
    },
    {
      name: 'Sales',
      type: 'number',
    },
  ],
};
const body = {
  input: 'Show me the sales for the last 3 months.',
  dataSourceSchemas: [exampleDataSourceSchema],
};
domo
  .post(`/domo/ai/v1/text/sql`, body)
  .then((response) => console.log(response));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
input String Required The prompt you are sending to the model
promptTemplate Object Optional An override for the prompt template used in the service. It has one property template, which expects a string.
parameters Object Optional Used with the promptTemplate for additional customization. You can pass any key, value pair of strings. See examples below.
model String Optional The id of the model you'd like to use if you don't want to use the default model.
dataSourceSchemas Array of Objects Optional The schemas of datasets that they service should take into account when generating the SQL query from the input prompt.
HTTP Request
POST /domo/ai/v1/text/sql HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The only required field in the request body is the input string, but you can provide additional properties in the request body to futher customize the text generation service. If you choose to use the promptTemplate property to override the default prompt template, you'll need to use ${input} into the template string to pass through the input of your prompt.
{
  "input": "Create a sql query to show me total sales.",
  "promptTemplate": {
    "template": "${input}. Show me the ${measure} for the last ${timeframe}"
  },
  "parameters": {
    "measure": "sales",
    "timeframe": "3 months"
  },
  "model": "8dc5737d-0bc8-425b-ad0d-5d6ec1a99e72",
  "dataSourceSchemas": [
    {
      "dataSourceName": "Sales",
      "description": "Sales Data",
      "columns": [
        {
          "name": "Date",
          "type": "date"
        },
        {
          "name": "Sales",
          "type": "number"
        }
      ]
    }
  ]
}
HTTP Response
Returns the prompt used and the response options from the model. If the a model was specified in the request, then modelId will return the model and isCustomerModel will be true.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "prompt": "You are a helpful assistant that generates SQL queries. Table `Voter Registration`, columns=[State:string, County:string, Party:string, Registered Voters: number, Total Votes:number]. Find the total votes by party in each county in the state of Utah. Use column aliases only for functions. Do not elaborate.",
    "choices": [
      {
        "output": "SELECT County, Party, SUM(`Total Votes`) AS TotalVotes FROM `Voter Registration` WHERE State = 'Utah' GROUP BY County, Party"
      }
    ],
    "modelId": "8dc5737d-0bc8-425b-ad0d-5d6ec1a99e72",
    "isCustomerModel": true
}
Image-to-Text
Generates a text response from an image.
Code Example
The body variable in this post request is an example of a sample request body.
export async function imageToText(base64) {
  // Example: OCR request body for AI API
  // Remove data URL prefix if present
  let pureBase64 = base64;
  if (pureBase64.startsWith('data:')) {
    pureBase64 = pureBase64.substring(pureBase64.indexOf(',') + 1);
  }
  const body = {
    input: 'return the text in the image, ensuring new lines are preserved',
    image: {
      mediaType: 'image/png',
      type: 'base64',
      data: pureBase64,
    },
    model: 'domo.domo_ai.domogpt-chat-medium-v1.1:anthropic',
    promptTemplate: {
      template: '${input}',
    },
    system: `You are an AI assistant tasked with performing Optical Character Recognition (OCR) on an image. Your goal is to accurately identify and transcribe any text present in the image by analyzing the image carefully and extract all visible text.\n\nFollow these steps to perform OCR on the image\n\n1. Examine the entire image thoroughly, paying attention to all areas where text might be present.\n2. Identify any visible text, including numbers, letters, symbols, and punctuation marks.\n3. Transcribe the text exactly as it appears in the image, maintaining the original spelling, capitalization, and punctuation.\n4. If the text is arranged in multiple lines or paragraphs, preserve this structure in your transcription.\n\nRemember, your task is to transcribe the text as accurately as possible without interpreting or summarizing its content. Focus solely on the text visible in the image.\n\nBefore responding think about your response step by step. Provide your final transcription within <answer> tags. For example\n<example>\n<answer>\nHello World\n</answer>\n</example>\n`,
  };
  const response = await fetch('/domo/ai/v1/image/text', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
  });
  if (!response.ok) {
    throw new Error('Image-to-text request failed');
  }
  return await response.json();
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
input String Required The prompt you are sending to the model (e.g., 'return the text in the image, ensuring new lines are preserved')
image Object Required The image object containing mediaType, type, and data (base64-encoded image).
model String Required The id of the model you'd like to use.
promptTemplate Object Optional An override for the prompt template used in the service. It has one property template, which expects a string.
system String Optional System prompt to guide the OCR process.
HTTP Request
POST /domo/ai/v1/image/text HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The required fields in the request body are the input string and the image object. You can provide additional properties in the request body to further customize the OCR service. If you choose to use the promptTemplate property to override the default prompt template, you'll need to use ${input} in the template string to pass through the input of your prompt.
{
  "input": "<input prompt>",
  "image": {
    "mediaType": "image/png",
    "type": "base64",
    "data": "<base64-encoded-image - Some formats may be restricted, such as HEIC or HEIF>"
  },
  "model": "domo.domo_ai.domogpt-chat-medium-v1.1:anthropic",
  "promptTemplate": {
    "template": "${input}"
  },
  "system": "You are an AI assistant tasked with performing Optical Character Recognition (OCR) on an image. ..."
}
HTTP Response
Returns the prompt used and the response from the model. The response will include the transcribed text from the image, typically within <answer> tags as specified in the system prompt.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
  "prompt": "return the text in the image, ensuring new lines are preserved",
  "choices": [
    {
      "output": "<The output text from the image, e.g., 'Hello World'>"
    }
  ],
  "modelId": "domo.domo_ai.domogpt-chat-medium-v1.1:anthropic",
  "isCustomerModel": false
}
AI Service Layer API
Text Generation
Text-to-SQL
Image-to-Text

AppDB API
AppDB allows the storage of arbitrary JSON documents similar to a normal NoSQL database. This enables the ability to store a state within your DomoApp. Optionally, you can also sync the data in AppDB back to a Domo DataSet. Three layers (analogous to traditional storage mechanisms) provide this data storage:
Datastores: Analogous to a database. A CustomApp has a single datastore that is created automatically, named with the CustomApp’s ID and managed transparently to the CustomApp.
Collections: Analogous to a collection in a NoSQL database or a table in a relational database. A datastore can have multiple collections defined.
Documents: Analogous to documents in a NoSQL database or a table row in a relational database. A collection can have multiple documents.
Defining Collections in the Manifest
Within the app manifest, you can define the Collections that you want your app to be able to use by simply listing them in a Collections property as in the following:
{
  "name": "Example comments app",
  "version": "1.0",
  "size": {
    "width": 2,
    "height": 2
  },
  "mapping": [],
  "collections": [
    {
      "name": "CommentsTable",
      "schema": {
        "columns": [
          { "name": "user", "type": "STRING" },
          { "name": "comment", "type": "STRING" }
        ]
      },
      "syncEnabled": true
    },
    {
      "name": "Users"
    }
  ],
  "id": "760ae493-6c29-4e61-8fe3-9c887265ea86"
}
As you can see, if you do not need to sync a Collection back to Domo, the only property you need to define is the Collection name. If you want it to sync back to Domo, you must also provide the schema you want for the Domo DataSet.
Schema Object
The schema object takes a list of columns. Each column has a name and a type. The following types are accepted.
STRING
LONG
DECIMAL
DOUBLE
DATE
DATETIME
Note
Documents that contain DATE or DATETIME data must be formatted as YYYY-MM-DD or YYYY-MM-DDTHH:MM:SSZ in order to be successfully synced to a Domo DataSet.
Warning
If your app has not yet created a DataSet and you provide the wrong data type in the schema section of your manifest, your collection will not be able to create a DataSet to export to. If, after adding documents to your collection and waiting the 15-minute period for a normally scheduled export, you do not see your AppDB DataSet in your data center, double check to ensure that your schema is set up correctly. A common mistake is to include a data type like NUMBER or INTEGER.
Warning
It's also important to be aware that Collections won't sync to Domo if the owner of the Collection doesn't have the correct permissions on the DataSet it's syncing to.
This is important to know in the case of someone who gets removed from their Domo instance. For example, if Bob owns a Collection that is synced to DataSet, and is then removed from the Domo instance, "deleted user" will remain as owner of the Collection unless updated; however, Bob will have no permissions on the DataSet, so it will stop syncing.
The new owner of the Collection not only has to be the owner, but has to be given Admin Permissions on the Collection as well.
Making API Calls to Your Collection
Examples of how to make calls to the Collections defined in your manifest are below. For now, you will not be able to make these calls in local dev without including a proxy. Instead, you must publish your app and ensure that it is making calls in an installed app.
Note
If you make any updates to the manifest and re-publish your app design, you will need to edit the installed app and re-save it for the manifest changes to take effect on the installed app (similar to what you would have to do when making changes to the mapping section of your manifest).
Create Document
Create a single document in a collection.
Code Example
The documentContent variable in this POST request is equal to the sample request body.
domo.post(`/domo/datastores/v1/collections/Users/documents/`, documentContent)
    .then(data => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
HTTP Request
POST /domo/datastores/v1/collections/{collectionName}/documents/ HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The request body accepts a document object. All document content should be wrapped in the content object. The properties of the document within the content object should match the schema of the collection if the schema is provided.
{
  "content": {
    "username": "Bill S. Preston, Esquire"
  }
}
HTTP Response
Returns the created document.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
    "customer": "excellent-adventure",
    "owner": 1089963280,
    "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
    "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
    "createdOn": "2019-03-04T16:59:25.184+0000",
    "updatedOn": "2019-03-04T16:59:25.184+0000",
    "updatedBy": 1089963280,
    "content": {
        "username": "Bill S. Preston, Esquire"
    },
    "syncRequired": true
}
Code Example
domo.post(`/domo/datastores/v1/collections/Users/documents`, {
  content: {
    username: 'Bill S. Preston, Esquire',
  },
});
List Documents
Lists all documents from a given Collection.
Code Example
domo
  .get(`/domo/datastores/v1/collections/Users/documents/`)
  .then((data) => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
HTTP Request
GET /domo/datastores/v1/collections/{collectionName}/documents/ HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns an array of documents.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
[
    {
        "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
        "customer": "excellent-adventure",
        "owner": 1089963280,
        "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
        "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
        "createdOn": "2019-03-04T16:59:25.184+0000",
        "updatedOn": "2019-03-04T16:59:25.184+0000",
        "updatedBy": 1089963280,
        "content": {
            "username": "Bill S. Preston, Esquire"
        },
        "syncRequired": true
    },
    {
        "id": "1e61d99d-9885-419a-a33e-3be3941ee720",
        "customer": "excellent-adventure",
        "owner": 1089963280,
        "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
        "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
        "createdOn": "2019-03-03T17:49:25.72+0000",
        "updatedOn": "2019-03-03T17:49:25.72+0000",
        "updatedBy": 1089963280,
        "content": {
            "username": "Ted Theodore Logan"
        },
        "syncRequired": true
    },
]
Get Document
Retrieves a single document from a Collection when given its document ID.
Code Example
domo
  .get(
    `/domo/datastores/v1/collections/Users/documents/b3ea3d2d-86c5-44e6-a2f4-985136bbbce1`,
  )
  .then((data) => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
documentId UUID Required The id of the document returned when it was created
HTTP Request
GET /domo/datastores/v1/collections/{collectionName}/documents/{documentId} HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns the indicated document.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
    "customer": "excellent-adventure",
    "owner": 1089963280,
    "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
    "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
    "createdOn": "2019-03-04T16:59:25.184+0000",
    "updatedOn": "2019-03-04T16:59:25.184+0000",
    "updatedBy": 1089963280,
    "content": {
        "username": "Bill S. Preston, Esquire"
    },
    "syncRequired": true
}
Update Document
Updates an existing document in a Collection when given its document ID.
Code Example
The documentContent variable in this PUT request is equal to the sample request body.
domo.put(`/domo/datastores/v1/collections/Users/documents/b3ea3d2d-86c5-44e6-a2f4-985136bbbce1`, documentContent)
    .then(data => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
documentId UUID Required The id of the document returned when it was created
HTTP Request
PUT /domo/datastores/v1/collections/{collectionName}/documents/{documentId} HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
{
    "content": {
        "username": "Bill S. Preston, Esquire",
        "Band": "Wyld Stallyns"
    }
}
HTTP Response
Returns the modified document.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
    "customer": "excellent-adventure",
    "owner": 1089963280,
    "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
    "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
    "createdOn": "2019-03-04T16:59:25.184+0000",
    "updatedOn": "2019-03-05T15:42:16.115+0000",
    "updatedBy": 1089963280,
    "content": {
        "username": "Bill S. Preston, Esquire",
        "Band": "Wyld Stallyns"
    },
    "syncRequired": true
}
Code Example
domo
  .put(
    `/domo/datastores/v1/collections/Users/documents/b3ea3d2d-86c5-44e6-a2f4-985136bbbce1`,
  )
  .then(console.log);
Delete Document
Permanently deletes a document from your application's Collection.
Warning
This is destructive and cannot be reversed. Deleting documents in an AppDB Collection may have performance implications with regard to syncing to its corresponding DataSet in Domo if the syncEnabled property is set to true for the Collection. Code Example domo.delete(/domo/datastores/v1/collections/Users/documents/1e61d99d-9885-419a-a33e-3be3941ee720);
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
documentId UUID Required The id of the document returned when it was created
HTTP Request
DELETE /domo/datastores/v1/collections/{collectionName}/documents/{documentId} HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns the parameter of a success or an error.
HTTP/1.1 200 OK
Query Documents
Any MongoDB query that can be used in a Mongo find() function can be used to query for documents in an AppDB Datastore. Official MongoDB query documentation is below: https://docs.mongodb.com/manual/reference/operator/query/
Example of querying for a document that includes a comment that has the word 'happy' (via a regex operator) or does not include the username 'Eeyore' (via the not equals operator) can be found below. The return value of this call will be an array of documents that matches the query.
HTTP Request
POST /domo/datastores/v1/collections/{collectionName}/documents/query HTTP/1.1
Content-Type: application/json
Accept: application/json
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
Request Body
{ $or:
       [
           { content.comments: {$regex: 'happy'} },
           { content.username: {$ne: 'Eeyore' } }
       ]
}
HTTP Response
Returns an array of documents matching the query.
HTTP/1.1 200 OK
[
    {
        "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
        "customer": "excellent-adventure",
        "owner": 1089963280,
        "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
        "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
        "createdOn": "2019-03-04T16:59:25.184+0000",
        "updatedOn": "2019-03-05T15:42:16.115+0000",
        "updatedBy": 1089963280,
        "content": {
            "username": "Mickey Mouse",
            "comments": "Happy Birthday!"
        },
        "syncRequired": true
     },
     {
        "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
        "customer": "excellent-adventure",
        "owner": 1089963280,
        "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
        "collectionId": "02c3a404-e18c-4f15-ac7f-a96cdb59ad10",
        "createdOn": "2019-03-04T16:59:25.184+0000",
        "updatedOn": "2019-03-05T15:42:16.115+0000",
        "updatedBy": 1089963280,
        "content": {
            "username": "Tigger",
            "comments": "Bouncing makes me so happy!"
        },
        "syncRequired": true
     },
]
Querying Based on Dates
Dates can be queried in AppDB using the MongoDB Extended JSON v2 spec shown below. This essentially casts the string provided to the "less than or equal to" operator into a date object. MongoDB documentation on the $date operator can be found here. The date string provided will need to be in the demonstrated ISO date format.
{
    "createdOn" : {
        "$lte" : {
            "$date" : "2020-05-12T00:00:00.000Z"
        }
    }
}
Query Documents with Aggregations
After the query limits the documents which will be returned by the API call, you can optionally add query string parameters to the URL to aggregate the query results. Each parameter (excluding groupby) has the optional ability to take an alias. While it is not required to alias each property that is being aggregated, it is useful in the event that you need to pass the same property to different aggregations to avoid name collisions.
HTTP Request
POST /domo/datastores/v1/collections/{collectionName}/documents/query?groupby={property1, property2}&count={alias}&{avg|max|min|sum}={property1 alias1, property2 alias2}&orderby={alias1 ascending|descending, alias2 ascending|descending} HTTP/1.1
Content-Type: application/json
Accept: application/json
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
query Object Required The JSON object that represents a Mongo query
groupby String Optional The comma-separated list of properties you wish to group by
count String Optional The name you wish to alias a count aggregation property
avg String Optional The comma-separated list of properties in which you wish to perform an average aggregation followed by the name you wish to alias the result
min String Optional The comma-separated list of properties in which you wish to perform a minimum aggregation followed by the name you wish to alias the result
max String Optional The comma-separated list of properties in which you wish to perform a maximum aggregation followed by the name you wish to alias the result
sum String Optional The comma-separated list of properties in which you wish to perform a sum aggregation followed by the name you wish to alias the result
unwind String Optional The comma-separated list of properties that you wish to unwind (the unwind operator flattens nested arrays - see MongoDB documentation for additional information)
orderby String Optional Alias of the aggregation you wish to order by (ascending or descending)
limit Integer Optional The number of documents in which to limit the number of return objects, default is 10,000
offset Integer Optional The number of documents in which to skip before returning documents, default is 0
Code Example
const url =
  '/domo/datastores/v1/collections/campaigns/documents/query?groupby=content.campaignName, content.month&count=documentCount&avg=content.clicks avgClicks, content.impressions avgImps&sum=content.clicks sumClicks, content.impressions sumImps&max=content.clicks maxClicks, content.impressions maxImps&min=content.clicks minClicks, content.impressions minImps&orderby=sumClicks descending';
domo.post(url, {}).then((data) => console.log(data));
Response
[
  {
    "maxImps": 1250,
    "sumClicks": 210,
    "sumImps": 2260,
    "documentCount": 2,
    "minImps": 1010,
    "avgImps": 1130,
    "campaignName": "Red Campaign",
    "minClicks": 90,
    "avgClicks": 105,
    "maxClicks": 120,
    "month": "February"
  },
  {
    "maxImps": 1150,
    "sumClicks": 190,
    "sumImps": 2050,
    "documentCount": 2,
    "minImps": 900,
    "avgImps": 1025,
    "campaignName": "Red Campaign",
    "minClicks": 85,
    "avgClicks": 95,
    "maxClicks": 105,
    "month": "January"
  },
  {
    "maxImps": 1000,
    "sumClicks": 100,
    "sumImps": 1000,
    "documentCount": 1,
    "minImps": 1000,
    "avgImps": 1000,
    "campaignName": "Blue Campaign",
    "minClicks": 100,
    "avgClicks": 100,
    "maxClicks": 100,
    "month": "January"
  },
  {
    "maxImps": 500,
    "sumClicks": 50,
    "sumImps": 500,
    "documentCount": 1,
    "minImps": 500,
    "avgImps": 500,
    "campaignName": "Blue Campaign",
    "minClicks": 50,
    "avgClicks": 50,
    "maxClicks": 50,
    "month": "February"
  }
]
Partially Update Documents Using Queries
Using standard mongo queries and update operations, you can do partial updates on your documents. The query must reference a document, or reference a property in a document.
Supported Operators:
currentDate
inc
min
max
mul
rename
set
unset
addToSet
pop
pullAll
Supported Modifiers:
each
position
slice
sort
Please refer to the official mongoDB documentation on Update Operators to better understand these operators and how to create them. Note that since we require that the query reference an existing document or property, the operator $setOnInsert is not supported.
Code Example
domo.put(`/domo/datastores/v1/collections/Users/documents/update`, body)
    .then(data => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
HTTP Request
PUT /domo/datastores/v1/collections/{collectionName}/documents/update
  Content-Type: application/json
  Accept: application/json
Request Body
Specification
The request body is a single object that must be structured as follows.
{
  "query": "{mongo query JSON}",
  "operation": "{mongo operation JSON}"
}
Example
{
  "query": { "content.username": "Bill S. Preston, Esquire" },
  "operation": {
    "$set": {
      "content.comment": "Excellent!"
    }
  }
}
HTTP Response
Returns the number of updated objects or properties.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
1
Bulk Operations
AppDB also allows for the creation, upsertion, and deletion of bulk lists of documents as shown in the examples below.
Create Documents in Bulk
Create multiple documents in a given collection in a single HTTP request.
Code Example
The documents variable in this post request is equal to the sample request body.
domo.post(`/domo/datastores/v1/collections/Users/documents/bulk`, documents)
    .then(data => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
HTTP Request
POST /domo/datastores/v1/collections/{collectionName}/documents/bulk HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The request body accepts an array of document objects.
[
  {
    "content": {
      "username": "Bill S. Preston, Esquire"
    }
  },
  {
    "content": {
      "username": "Ted Theodore Logan"
    }
  }
]
HTTP Response
Returns the number of documents created successfully.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
   "Created": 2
}
Upsert Documents in Bulk
To upsert documents, you will need to provide the content object for each document and the ID for existing objects that need to be updated. Objects that have an ID will be updated; those with no ID (or where the ID is not found in the Collection) will be created.
Code Example
The documents variable in this POST request is equal to the sample request body.
domo.put(`/domo/datastores/v1/collections/Users/documents/bulk`, documents)
    .then(data => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
HTTP Request
PUT /domo/datastores/v1/collections/{collectionName}/documents/bulk HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
The request body accepts an array of document objects.
[
  {
    "id": "b3ea3d2d-86c5-44e6-a2f4-985136bbbce1",
    "content": {
      "username": "Bill S. Preston, Esquire",
      "Band": "Wyld Stallyns"
    }
  },
  {
    "id": "1e61d99d-9885-419a-a33e-3be3941ee720",
    "content": {
      "username": "Ted Theodore Logan",
      "Band": "Wyld Stallyns"
    }
  },
  {
    "content": {
      "username": "Rufus"
    }
  }
]
HTTP Response
Returns the number of documents created and/or updated.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "Updated": 2,
    "Created": 1
}
Delete Documents in Bulk
Provides a list of document IDs to be permanently deleted as a comma-separated query parameter.
Warning
This is destructive and cannot be reversed. Deleting documents in an AppDB collection may have performance implications with regard to syncing to its corresponding DataSet in Domo if the syncEnabled property is set to true for the Collection.
domo
  .delete(
    `/domo/datastores/v1/collections/Users/documents/bulk?ids=2bdd6370-85af-4e06-aadb-380839e4de8c,c78ba737-5f84-49c9-8ac9-58615a0f8aa8,1e61d99d-9885-419a-a33e-3be3941ee720`,
  )
  .then((data) => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name given to the collection in the manifest
idList Array Required Comma-separated list of document Ids
HTTP Request
DELETE /domo/datastores/v1/collections/{collectionName}/documents/bulk?ids={idList} HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "Deleted": 3
}
Programmatic Operations for Collections
While most of the time you are going to want to define a Collection in your manifest and have the platform automatically create the Collection for you, there is also the option to programmatically manipulate Dollections from your app code.
Create a Collection
To create a Collection programmatically, send a POST request to the below endpoint and provide as the body of the request the same JSON value that you would have provided in your manifest for a Collection. Once created, the Collection can be retrieved by the name you provided as usual.
Code Example
The collection variable in this code sample is equal to the collection object in the sample request body.
domo
  .post(`/domo/datastores/v1/collections`, collection)
  .then((data) => console.log(data));
HTTP Request
POST /domo/datastores/v1/collections HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
{
  "name": "Users",
  "schema": {
    "columns": [
      { "name": "username", "type": "STRING" },
      { "name": "band", "type": "STRING" }
    ]
  },
  "syncEnabled": true
}
HTTP Response
Returns the created Collection.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "6de8034e-0aa3-4fd9-ac1d-9a1ffeccb759",
    "customer": "excellent-adventure",
    "owner": 1089963280,
    "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
    "name": "Users",
    "schemaJson": "{\"columns\":[{\"type\":\"STRING\",\"name\":\"username\",\"visible\":true},{\"type\":\"STRING\",\"name\":\"band\",\"visible\":true}]}",
    "syncRequired": true,
    "fullReplaceRequired": true,
    "lastSync": "1970-01-02T00:00:00.000+0000",
    "updatedBy": 1089963280,
    "schema": {
        "columns": [
            {
                "type": "STRING",
                "name": "username",
                "visible": true
            },
            {
                "type": "STRING",
                "name": "band",
                "visible": true
            }
        ]
    },
    "createdOn": "2019-03-04T18:47:12.327+0000",
    "updatedOn": "2019-03-04T18:47:12.327+0000",
    "exportable": true,
    "syncEnabled": true
}
List Collections
Retrieves a list of the existing Collections for your application.
Code Example
domo.get(`/domo/datastores/v1/collections/`).then((data) => console.log(data));
HTTP Request
GET /domo/datastores/v1/collections HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns an array of Collection objects.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
[
  {
    "id": "6de8034e-0aa3-4fd9-ac1d-9a1ffeccb759",
    "customer": "excellent-adventure",
    "owner": 1089963280,
    "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
    "name": "Users",
    "schemaJson": "{\"columns\":[{\"type\":\"STRING\",\"name\":\"username\",\"visible\":true},{\"type\":\"STRING\",\"name\":\"band\",\"visible\":true}]}",
    "syncRequired": true,
    "fullReplaceRequired": true,
    "lastSync": "1970-01-02T00:00:00.000+0000",
    "updatedBy": 1089963280,
    "schema": {
        "columns": [
            {
                "type": "STRING",
                "name": "username",
                "visible": true
            },
            {
                "type": "STRING",
                "name": "band",
                "visible": true
            }
        ]
    },
    "createdOn": "2019-03-04T18:47:12.327+0000",
    "updatedOn": "2019-03-04T18:47:12.327+0000",
    "exportable": true,
    "syncEnabled": true
  },
  {
        "id": "6b3b7ab7-9e72-483e-bc79-f05011cee5ef",
        "customer": "excellent-adventure",
        "owner": 1089963280,
        "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
        "name": "Comments",
        "datasourceId": "62b4a99f-a98f-4f01-92f2-b02c35693c97",
        "schemaJson": "{\"columns\":[{\"type\":\"STRING\",\"name\":\"user\",\"visible\":true},{\"type\":\"STRING\",\"name\":\"comment\",\"visible\":true}]}",
        "syncRequired": false,
        "fullReplaceRequired": true,
        "lastSync": "2019-01-29T19:15:10.239+0000",
        "updatedBy": 1089963280,
        "schema": {
            "columns": [
                {
                    "type": "STRING",
                    "name": "user",
                    "visible": true
                },
                {
                    "type": "STRING",
                    "name": "comment",
                    "visible": true
                }
            ]
        },
        "createdOn": "2019-01-15T20:17:48.533+0000",
        "updatedOn": "2019-01-29T19:15:10.255+0000",
        "exportable": true,
        "syncEnabled": true
    }
]
Update Collection
This PUT request allows you to modify any of your Collections programmatically.
Warning
If you manually override the properties of a Collection that exists in your manifest, then any time an app Card is saved, the Card will revert back to the manifest definition of that Collection. It is best practice to only update Collections that you have created manually. Otherwise, to update a Collection, simply update the manifest.
Code Example
domo
  .put(`/domo/datastores/v1/collections/{collectionName}`, collection)
  .then((data) => console.log(data));
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name of the collection provided when the collection was created
HTTP Request
PUT /domo/datastores/v1/collections/{collectionName} HTTP/1.1
Content-Type: application/json
Accept: application/json
Request Body
{
  "id": "6de8034e-0aa3-4fd9-ac1d-9a1ffeccb759",
  "schema": {
    "columns": [
      {
        "type": "STRING",
        "name": "username",
        "visible": true
      },
      {
        "type": "STRING",
        "name": "band",
        "visible": true
      },
      {
        "type": "STRING",
        "name": "favorite color",
        "visible": true
      }
    ]
  },
  "syncEnabled": true
}
HTTP Response
Returns the updated Collection object.
{
  "id": "6de8034e-0aa3-4fd9-ac1d-9a1ffeccb759",
  "customer": "excellent-adventure",
  "owner": 1089963280,
  "datastoreId": "d4a4b9c4-e123-41ce-8f93-dcafbeea4642",
  "name": "Users",
  "schemaJson": "{\"columns\":[{\"type\":\"STRING\",\"name\":\"username\",\"visible\":true},{\"type\":\"STRING\",\"name\":\"band\",\"visible\":true},{\"type\":\"STRING\",\"name\":\"favorite color\",\"visible\":true}]}",
  "syncRequired": true,
  "fullReplaceRequired": false,
  "lastSync": "1970-01-02T00:00:00.000+0000",
  "updatedBy": 1089963280,
  "schema": {
    "columns": [
      {
        "type": "STRING",
        "name": "username",
        "visible": true
      },
      {
        "type": "STRING",
        "name": "band",
        "visible": true
      },
      {
        "type": "STRING",
        "name": "favorite color",
        "visible": true
      }
    ]
  },
  "createdOn": "2019-03-04T18:47:12.332+0000",
  "updatedOn": "2019-03-04T18:59:06.168+0000",
  "exportable": true,
  "syncEnabled": true
}
Delete a Collection
Programmatically deletes a Collection.
Warning
This is destructive and cannot be reversed.
Code Example
domo.delete(`/domo/datastores/v1/collections/{collectionName}`);
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
collectionName String Required The name of the collection provided when the collection was created
HTTP Request
DELETE /domo/datastores/v1/collections/{collectionName} HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns the parameter of a success or an error.
HTTP/1.1 200 OK
Manually Exporting Collections
Collections that are marked as syncEnabled will be exported to the Domo instance every 15 minutes. If for some reason, you need the Collections for your app to be exported at a certain moment in time, you can manually call the export endpoint, and it will begin the export process. If there is already an export in progress, you will receive a 423 LOCKED HTTP response. Otherwise, you will receive a 200 OK HTTP response suggesting that the export request was successfully received.
The export endpoint is a POST request that takes no body.
Code Example
domo.post(`/domo/datastores/v1/export`);
HTTP Request
POST /domo/datastores/v1/export HTTP/1.1
Content-Type: application/json
Accept: application/json
HTTP Response
Returns the parameter of success or error.
HTTP/1.1 200 OK
By default, hitting this endpoint will only export Collections that were created by the app instance you are routing the request against. If you'd like to export all Collections wired to the app instance, regardless of which instance created them, you can set includeRelatedCollections=true in the query string.
const exportCollection = async () => {
  const response = await fetch(
    '/domo/datastores/v1/export?includeRelatedCollections=true',
    {
      body: '{}',
      method: 'POST',
    },
  );
  console.log(response);
  return response;
};
Document Level Security Filtering
While developing your application, you might find yourself creating specific queries to limit users to see or use only certain data that is stored in your AppDB Collections. These queries might be aimed at accomplishing some of the following use-case examples:
A user should only see data that has been assigned to a certain region or team.
A user should only be able to update AppDB documents that they themselves created.
Only a manager who belongs to a certain Domo group can delete documents from your Collection.
While your front-end application code can accomplish these examples in an attempt to secure your app, it is also possible for a user to bypass your client-side code and write their own code that interfaces with the AppDB endpoints directly. In order to secure your documents on the server side, document-level filtering rules can be applied to the Collection within the manifest of your application. An example of a Collection with a document-level filter applied is shown below.
"collections": [
    {
      "name": "secureCollection",
      "filters": [
        {
          "name": "defaultFilter",
          "applyOn": [
            "READ",
            "UPDATE",
            "DELETE"
          ],
          "applyTo": [
            {
              "type": "GROUP_ID",
              "values": [
                12,
                15
              ]
            }
          ],
          "applyToAll": false,
          "limitToOwner": false,
          "query": {
            "content.region": "West"
          }
        }
      ]
    }
  ]
In this example, any user who belongs to the group with ID 12 or 15 in Domo will only be able to see, modify, or delete documents that have the value of “West” in the document’s content.region property. As you can see, the filters property of this Collection's configuration object takes a list of filter rules. Adding multiple filter rules in the filters property will chain together the rules as an OR statement as in any standard data query language. There are several properties of a filter rule that are required to secure your documents. The following image groups them together by function.
Filter Rule
name – The name of the filter rule that you intend to create. This will be used mainly as a description of what you intend the rule to accomplish.
Who
applyTo – The property that describes who to apply this filter rule to. This property takes a list of one or more condition objects.
condition – The condition that must be met in order for the filter rule to apply to the current user. The condition contains two properties.
type – The property that determines what kind of condition to compare against the current user:
USER_ID
GROUP_ID
values – The property that takes a list of possible values that the current user will be compared to. For example, if the type of the condition is USER_ID and the values list contains the current user’s ID, then the condition will evaluate to true, and this filter rule will apply to the current user. If the list does not contain the user’s ID, the condition will evaluate to false, and the filter rule will not apply and will be skipped.
Wildcards: In addition to listing static values, this field also supports two wildcards: %userId% and %groupIds%. An example of using one is, "query": {"content.user": "%userId%"}, which would replace the %userId% with the ID of the current user.
applyToAll – A boolean value that overrides the applyTo property. If this property is set to true, then the current filter rule will apply to all users of the app.
What
query – The AppDB query that should be combined with any query the user is trying to make to further filter their request for documents. For example, let’s say the user belongs to the “West Sales” group, as defined in our example Collection, and they write the following query to search for documents:
{ "content.country": "US" }
In this case, because the user is part of a group defined in the applyTo section of the filter rule definition, the condition would be evaluated to true and our additional document-level security filter would be applied. The resulting query to AppDB on the server side would be transformed to look similar to the following:
{ "content.country": "US", "content.region": "West" }
So although the user requested all documents from the “US” country, only those documents which are both in the “US” and the “West” region will be returned to the user.
limitToOwner – This property takes a boolean that determines whether to add another query to any request that limits documents to only those created by the current user. So, if this flag were set to true, then the resulting query on the backend would be transformed still further to add the user’s ID to the request. In the case of our previous example, even though the user requested documents from the “US”, they would be returned all documents from the “US” that are in the “West” region and created by the existing user.
{ "content.country": "US", "content.region": "West", "owner": "123456" }
When
applyOn – Takes a list of HTTP methods that the current filter rule should apply to. The list of methods is as follows:
READ
UPDATE
DELETE
Any AppDB endpoint that performs one of these operations will apply extra filtering prior to executing the request that the user specified. From our previous example: If a user were given the document ID of a document that was not in the “West” region and the DELETE method existed in a filter rule that applied to those documents, then when they attempt to call the delete endpoint and use that document ID, they would not be allowed to delete it. In this case, if they called the single document's delete endpoint, it would return a '404 not found' error. If they called the bulk endpoint, it would return '0 documents deleted'.
Collection Level Security
Some applications might find it necessary to add security permissions at the Collection level. This could range from adding or removing the ability for a user to modify the definition of a programmatically created Collection to removing the ability of any user of the app to delete any documents from the Collection. By default, all users of the app who own the Collection have all permissions to the Collection and its documents until the permissions are updated to be more specific.
Modify Permissions
Assuming you already have permission to modify the Collection, you can change the permissions of a Collection by hitting the following endpoint:
Code Example
domo.put(
  '/domo/datastores/v1/collections/Users/permission/RYUU_APP/733ff55b-387c-472e-b3c7-9911c7057f5f?permissions=read,create_content,update_content,read_content',
);
HTTP Request
PUT /domo/datastores/v1/collections/{collectionName}/permission/{entity}/{entityId}?permissions={permissionList} HTTP/1.1
Content-Type: application/json
HTTP Response
HTTP/1.1 200 OK
Entity
The following are the possible entities that can be used in the entity path parameter in the above endpoint:
USER
GROUP
RYUU_APP
The value you choose for the entity path parameter will determine which entity ID you will need to provide for the entityId path parameter. For users and groups, you will use either the user ID or the group ID. If you want to modify permissions for anyone who has access to the app as a whole, you can use the RYUU_APP path parameter and provide the app instance ID as the entityId. The app instance ID is the first UUID provided in the URL of the iframe that houses the app. You should be able to pull down the URL in your JavaScript using window.location and parsing the first UUID programmatically.
Permission List
The following are the possible permissions that can be added using the permissions query parameter:
admin - All permissions to the Collection and its documents
write - Permission to update properties of the Collection
read - Permission to read the properties of the Collection
share - Permission to add or remove any permissions this entity already has
delete - Permission to delete the Collection or its documents
create_content - Permission to create documents in the Collection
update_content - Permission to update documents in the Collection
read_content - Permission to read documents in the Collection
delete_content - Permission to delete documents in the Collection
Delete Permissions
You can remove all permissions for an entity using the endpoint below. If all entities’ permissions are removed, then only users with the Manage AppDB grant will still have access.
Code Example
domo.delete(
  '/domo/datastores/v1/collections/Users/permission/RYUU_APP/733ff55b-387c-472e-b3c7-9911c7057f5f',
);
HTTP Request
DELETE /domo/datastores/v1/collections/{collectionName}/permission/{entity}/{entityId} HTTP/1.1
Content-Type: application/json
HTTP Response
HTTP/1.1 200 OK
AppDB API
Defining Collections in the Manifest
Making API Calls to Your Collection
Create Document
List Documents
Get Document
Update Document
Delete Document
Query Documents
Query Documents with Aggregations
Partially Update Documents Using Queries
Bulk Operations
Create Documents in Bulk
Upsert Documents in Bulk
Delete Documents in Bulk
Programmatic Operations for Collections
Create a Collection
List Collections
Update Collection
Delete a Collection
Manually Exporting Collections
Document Level Security Filtering
Collection Level Security

Code Engine API
Code Engine is a Domo-native runtime environment that can execute JavaScript or Python code. In Code Engine, you can write, test, and distribute functions usable by Workflows and other Apps by Domo.
Domo provides a library of global packages and their related functions for common integrations and services that anyone can use in their Domo instance. You can also create your own functions with custom code to perform automated services in your instance.
You can learn more about setting up Code Engine functions in Domo's Knowledge Base.
If you haven't leveraged Code Engine functions from within Apps before, checkout the guide on hitting Code Engine from an App, which details how to configure your manifest.json file and wire up Code Engine packages to your app.
Run Code Engine Function
Runs a Code Engine function and returns output of that function.
Code Example
const startFunction = (functionAlias, inputParameters = {}) => {
    domo.post(`/domo/codeengine/v2/packages/${functionAlias}`, inputParameters
    ).then(data => {
        console.log(data);
    }).catch(err => {
        console.log(err);
    })
};
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
functionAlias String Required The name given to the Code Engine package in the manifest
HTTP Request
POST /domo/codeengine/v2/packages/{functionAlias}
Request Body
The request body accepts an object containing the input parameters required to run the code engine function. These parameters are also defined in the manifest.json file and properties in the object should correspond to the alias of the parameter.
{"parameter1": parameter1, "parameter2": parameter2}
HTTP Response
Returns the result of the Code Engine function. This result is defined in the Code Engine function and function configuration "Output" tab. This output should also be defined in the output property of the packageMapping object in the manifest file.
Code Engine API
Run Code Engine Function

Data API
Base URL
GET /data/v1/:alias?:queryOperators
alias: the name you provided for the dataset mapping in your app's manifest
queryOperators: URL parameters that enable you to create custom queries of the mapped dataset. Possible query operators are:
avg
calendar
count
dategrain
fields
filter
groupby
limit
max
min
offset
orderby
sum
unique
aggregations
Consolidate all rows of a column into a single value or override the default aggregations for dategrain and groupby clauses. Multiple fields can be specified by delimiting with commas.
GET /data/v1/:alias?{avg|count|max|min|sum|unique}=:fieldAlias1,:fieldAlias2
When aggregations are requested without a groupby or dategrain, then a single row of data will be returned with the aggregated fields only.
calendar
Specify which calendar to use for date-related operations such as todate, last, and dategrain.
GET /data/v1/:alias?calendar={fiscal|standard}
dategrain
Perform a groupby with predefined date grains. By default, numerical columns are summed and unique entries of non-numerical columns are counted. Can be combined with an aggregation to override this default behavior.
GET /data/v1/:alias?dategrain=:dateField by {day|week|month|quarter|year}
Note: dategrain adds new columns
When graining by "week", "month", or "quarter", a column named CalendarXXXX will be returned with the data (e.g. CalendarMonth for month date graining). Date graining by "day" will return a column Date, and date graining by "year" will return a column Year.
If you already have a column with that name, it will be overridden by this new date field. In addition, the column you request as the date grain will not be present in the result by its original name.
fields
Limit the result set to specific columns from the dataset by providing either the field alias or the original column name (if no alias was defined in the manifest). Multiple fields can be combined into a comma separated string.
GET /data/v1/:alias?fields=:fieldAlias1,:fieldAlias2,:fieldAlias3
filter
Limit the rows returned by the request by providing more fine-grained filters. Multiple filter parameters can be combined into a single comma separated string.
GET /data/v1/:alias?filter=amount > 1000, name contains 'Foobar'
Operators
Op1  Op2         Description
===  ===         ===========
<                Less than
<=               Less than or equals
>                Greater than
>=               Greater than or equals
=    ==          Equals
!=               Not equals
~    contains    Contains
!~   !contains   Doesn't contain
in               In an array of values. ie ["foo", "bar"]
!in              Not in an array of values. ie ["foo", "bar"]
todate           Period to date: eg :dateField todate {day|week|month|quarter|year}
last             Rolling Period: eg :dateField last :int {hours|days|weeks|months|quarters|years}
groupby
Aggregates identical data into groups. By default, numerical columns are summed and unique entries of non-numerical columns are counted. Can be combined with an aggregation to override this default behavior. Multiple columns can be grouped by delimiting each with a comma.
GET /data/v1/:alias?fields=color,shape,qty&groupby=color,shape
limit & offset
Provides the ability to paginate the query results.
GET /data/v1/:alias?offset=:int&limit=:int
orderby
Rows can be ordered by any column in ascending or descending order. The order defaults to ascending and a multi-column order can be defined by delimiting each order clause with a comma.
GET /data/v1/:alias?orderby=:fieldName {ascending|descending}
Note: You cannot order on an aggregation
Data Formats
You can control the format of the data returned from this endpoint by setting the request Accept header. If leveraging the domo.js library, the same can be accomplished by passing a format option in the request. Please refer to the domo.get() documentation for further details.
array-of-objects
Header
XMLHttpRequest.setRequestHeader('Accept', 'array-of-objects');
domo.js
domo.get('my-alias', { format: 'array-of-objects' });
Example Response
[
  { "first": "Joe", "last": "Jacobs", "age": 39 },
  { "first": "Henry", "last": "Woolington", "age": 23 }
]
CSV
Header
XMLHttpRequest.setRequestHeader('Accept', 'text/csv');
domo.js
domo.get('my-alias', { format: 'csv' });
Example Response
'first', 'last', 'age';
'Joe', 'Jacobs', '39';
'Henry', 'Woolington', '23';
Excel
Header
XMLHttpRequest.setRequestHeader(
  'Accept',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
);
domo.js
domo.get('my-alias', { format: 'excel' });
Detailed JSON
Header
XMLHttpRequest.setRequestHeader('Accept', 'application/json');
domo.js
domo.get('my-alias', { format: 'array-of-arrays' });
Example Response
{
  "columns": ["first", "last", "age"],
  "datasource": "93a5b974-1aac-49fc-ba9a-a67dff658be6",
  "device": "ad3-prod1-03",
  "duration": "35",
  "fromcache": "true",
  "metadata": [
    {
      "dataSourceId": "93a5b974-1aac-49fc-ba9a-a67dff658be6",
      "type": "STRING"
    },
    {
      "dataSourceId": "93a5b974-1aac-49fc-ba9a-a67dff658be6",
      "type": "STRING"
    },
    { "dataSourceId": "93a5b974-1aac-49fc-ba9a-a67dff658be6", "type": "LONG" }
  ],
  "numColumns": 3,
  "numRows": 2,
  "queryUrl": "/query/training/93a5b974-1aac-49fc-ba9a-a67dff658be6",
  "rows": [
    ["Joe", "Jacobs", 39],
    ["Henry", "Woolington", 23]
  ]
}
Beast Modes
Previously a known limitation of the Data API, you can now optionally use beast modes in your queries. In order to use beast modes in your data request, the useBeastMode query parameter must be set to true.
Basic Example
The following example shows a query that returns only a beast mode column (as noted by the fields operator). You'll notice that the useBeastMode=true query string parameter is added to this request.
domo
  .get('/data/v1/dataAlias?useBeastMode=true&fields=beastModeAlias')
  .then(function (data) {
    console.log('data', data);
  });
In this example, the beastModeAlias field is the alias provided to the column in your manifest that maps to a beast mode that has been wired up on the wiring page of an app.
Warning
By adding the useBeastMode=true query string parameter to your data calls, some built-in query functionality is disabled.
Traditionally, when not using beast modes in your request, if you provide a groupby operator but don't specify an aggregation operator, Domo will automatically sum the other columns for you (if they are numbers) or count them (if they are strings or dates). When beast mode is enabled, you must explicitly provide some sort of aggregation any time you use a groupby operator. That can either be by using an aggregation operator in the query string or by providing an aggregation function in the formula of your beast mode calculation. It must be thought of as structuring a SQL query, wherein if you create a SQL query that has a group by but not all fields in the SELECT statement were aggregated or included in the group by, SQL will throw an error. It might look something like this:
ERROR: column “MY_TABLE.MY_COLUMN” must appear in the GROUP BY clause or be used in an aggregate function
The reason that the Data API's default functionality must be turned off when using beast modes is that a beast mode can have its own aggregation in a calculation. If a sum or a count is assumed, as it would be traditionally, and the beast mode already contained an aggregate function in its calculation, then you would run into an "aggregation within an aggregation error."
Aggregation Example
If you want to sum a beast mode that does not already contain any aggregation functions in its formula and group by another column, you can use a request similar to the following. Note that if you use an aggregation operator on a beast mode column that already has an aggregation function in its formula, it will cause an error to occur (aggregate within an aggregate).
domo
  .get(
    '/data/v1/dataAlias?useBeastMode=true&fields=beastModeAlias,reps&sum=beastModeAlias&groupby=reps',
  )
  .then(function (data) {
    console.log('data', data);
  });
If you want to obtain the same results but your beast mode already contains a sum function in its formula, then you can exclude the sum operator as a query parameter. Note that if your beast mode does contain an aggregation in its formula and you are including multiple fields in your query, you must specify a groupby operator so that the query knows how to group the results of the beast mode's aggregation function.
domo
  .get(
    '/data/v1/dataAlias?useBeastMode=true&fields=beastModeAlias,reps&groupby=reps',
  )
  .then(function (data) {
    console.log('data', data);
  });
Known Limitation
You cannot use the filter operator on a beast mode that contains an aggregate function (the equivalent of a having clause which is not supported in Domo today).
SQL API
You can now use SQL to query your Domo DataSet as an alternative to using the Data API. You can use the same SQL you're used to except JOINs and trigonometric functions. For example:
domo
  .post('/sql/v1/dataAlias', 'SELECT * FROM dataAlias limit 100', {
    contentType: 'text/plain',
  })
  .then(function (data) {
    console.log({ data });
  });
Warning
The SQL API does not currently support page filters.
Data API
Base URL
aggregations
calendar
dategrain
fields
filter
groupby
limit & offset
orderby
Data Formats
Beast Modes
SQL API

Files API
Domo supports nearly 100 different file types across over 300 file extensions. Please reach out to Domo Support if you have a question about supported file types, as the list changes often.
Domo Bricks
Currently, Domo Bricks do not support the Files API.
Upload a file
Uploading a new file can be accomplished through the following request. You will pass in the file to upload, and Domo will store it and generate a unique identifier for the file, which is returned to you.
Default Permissions
The App Framework will automatically secure the file permissions so it can only be accessed by the same user who uploaded it, unless the public param is set to true. In that case, all users in the Domo instance will be able to access the file. File permissions can be updated to give access to specific users and groups, if needed. You can find out how to do that by reviewing the Update file permissions API.
Code Example
function uploadFile(name, description = "", public = false, file) {
  const formData = new FormData();
  formData.append("file", file);
  const url = `/domo/data-files/v1?name=${name}&description=${description}&public=${public}`;
  const options = { contentType: "multipart" };
  return domo.post(url, formData, options);
}
Query Parameters
PROPERTY NAME TYPE REQUIRED DESCRIPTION
name String Required The name to be given to the file in Domo
description String Optional A description of the file
public Boolean Optional Whether the permissions of the file are set to public - this is false by default in the App Framework
HTTP Request
POST /domo/data-files/v1?name={name}&description={description}&public={public} HTTP/1.1
Accept: application/json
Request Body
The request body is a JavaScript FormData() object that supports a multipart upload. The name given to the file to be appended to the FormData object is file.
HTTP Response
Returns the ID of the created file.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "dataFileId": 401
}
Upload a file revision
The Files API provides versioning support for files that have been uploaded. You may add another version of a file by sending a PUT request to the files endpoint referencing the dataFileId of the file you wish to revise.
Code Example
function uploadRevision(file, dataFileId) {
  const formData = new FormData();
  formData.append("file", file);
  const url = `/domo/data-files/v1/${dataFileId}`;
  const options = { contentType: "multipart" };
  return domo.put(url, formData, options);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
dataFileId Integer Required The id of the file of which you wish to upload a revision
HTTP Request
PUT /domo/data-files/v1/{dataFileId} HTTP/1.1
Accept: application/json
Request Body
The request body is a javascript FormData() object which supports a multipart upload. The name given to the File that is to be appended to the FormData object is 'file'.
HTTP Response
Returns the revision id of the uploaded revision file.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "revisionId": 430
}
Get all files metadata
Each file that you upload has corresponding metadata. This endpoint allows you to list all the metadata for each file you have access to. If you want to limit the files to just those that you uploaded you can provide a limitToOwned boolean flag as a query parameter.
Code Example
function getFileDetailsList(ids = null, expand = null, limitToOwned = false) {
  const params = new URLSearchParams();
  if (ids !== null) params.append("ids", ids);
  if (expand !== null) params.append("expand", expand);
  const queryString = params.toString();
  const url = `/domo/data-files/v1/details/?limitToOwned=${limitToOwned}${
    queryString !== "" ? `&${queryString}` : ""
  }`;
  return domo.get(url);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
ids Integer Array Optional An array of File Ids that you wish to be returned if you only want a subset of files
expand String Array Optional An array of string properties that you wish to see additional details of (either revisions, metadata, or both)
limitToOwned Boolean Optional Whether or not to limit the result to only files that you uploaded
HTTP Request
GET /domo/data-files/v1/details?limitToOwned={limitToOwned}&ids={ids}&expand={expandList} HTTP/1.1
Accept: application/json
HTTP Response
Returns an array of file objects.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
[
    {
        "dataFileId": 401,
        "name": "\"SampleFile\"",
        "responsibleUserId": 1089963280,
        "currentRevision": {
            "dataFileRevisionId": 430,
            "dataFileId": 401,
            "contentType": "application/pdf",
            "uploadUserId": 1089963280,
            "sizeBytes": 142783,
            "uploadTimeMillis": 199,
            "md5Hash": "B6C962A9288F132762051A6A33708B90",
            "datetimeUploaded": 1731611168000,
            "scanState": "SAFE",
            "sha256HashValue": "5E3EF0EF4CFAD65A1831D866DEEBD932C5A0AA3484A558FD0D1CA3EB852AE1BF"
        },
        "datetimeCreated": 1731611168000,
        "revisions": [],
        "existing": false
    }
]
Get file metadata by ID
Given a known file ID, this endpoint allows you to list the metadata for that specific file.
Code Example
function getFileDetails(dataFileId, expandList = null) {
  let url = `/domo/data-files/v1/${dataFileId}/details`;
  if (expandList !== null) {
    url += `?expand=${expandList.join()}`;
  }
  return domo.get(url);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
expand String Optional An array of string properties that you wish to see additional details of (either revisions, metadata, or both)
HTTP Request
GET /domo/data-files/v1/{dataFileId}/details?expand={expandList} HTTP/1.1
Accept: application/json
HTTP Response
Returns the file details object.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
    {
        "dataFileId": 401,
        "name": "\"SampleFile\"",
        "responsibleUserId": 1089963280,
        "currentRevision": {
            "dataFileRevisionId": 430,
            "dataFileId": 401,
            "contentType": "application/pdf",
            "uploadUserId": 1089963280,
            "sizeBytes": 142783,
            "uploadTimeMillis": 199,
            "md5Hash": "B6C962A9288F132762051A6A33708B90",
            "datetimeUploaded": "2019-03-06T00:26:37.000+0000",
            "scanState": "SAFE",
            "sha256HashValue": "5E3EF0EF4CFAD65A1831D866DEEBD932C5A0AA3484A558FD0D1CA3EB852AE1BF"
        },
        "datetimeCreated": "2019-03-04T21:41:01.000+0000",
        "revisions": [],
        "existing": false
    }
Download a file
Below is the basic request for downloading a file. Depending on the type of file, this endpoint can be referenced inline in your application or called via an HTTP request. In this example, the responseType of the XHR request is being set to blob so that our code can reference it as a binary large object when passing the response to the Download method.
Code Example
import Download from "downloadjs";
function downloadFile(dataFileId, filename, revisionId) {
  const options = { responseType: "blob" };
  const url = `/domo/data-files/v1/${dataFileId}${
    !!revisionId ? `/revisions/${revisionId}` : ""
  }`;
  return domo.get(url, options).then((data) => {
    Download(data, filename);
  });
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
dataFileId Integer Required The id of the file you wish to download
revisionId Integer Optional The id of the file revision you wish to download
HTTP Request
To download the current file version:
GET /domo/data-files/v1/{dataFileId} HTTP/1.1
Accept: application/json
To download a previous version:
GET /domo/data-files/v1/{dataFileId}/revisions/{revisionId} HTTP/1.1
Accept: application/json
HTTP Response
Returns the File to be downloaded.
HTTP/1.1 200 OK
Content-Type: {mime-type of the file}
Delete a file
Permanently deletes a File from your instance.
Warning
This is destructive and cannot be reversed. However, the delete does occur at the revision level, so if you unintentionally delete a file, the previous version will now be the current version of the file for a given file Id.
Code Example
function deleteFile(dataFileId, revisionId) {
  const url = `/domo/data-files/v1/${dataFileId}/revisions/${revisionId}`;
  return domo.delete(url);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
dataFileId Integer Required The id of the file you wish to delete
revisionId Integer Optional The id of the revision file you wish to delete
HTTP Request
DELETE /domo/data-files/v1/{dataFileId}/revisions/{revisionId} HTTP/1.1
Accept: application/json
HTTP Response
Returns the parameter of success or error based on the file Id and the revisionId being valid.
HTTP/1.1 200 OK
Get file permissions
Code Example
function getFilePermissions(dataFileId) {
  const url = `/domo/data-files/v1/${dataFileId}/permissions`;
  return domo.get(url);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
dataFileId Integer Required The id of the file you wish to get permission details for
HTTP Request
GET /domo/data-files/v1/{dataFileId}/permissions HTTP/1.1
Accept: application/json
HTTP Response
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "publicAccess": false,
    "entries": [
        {
            "entityType": "USER",
            "entityId": "1089963280",
            "grant": "READ_WRITE_DELETE_SHARE_ADMIN",
            "pass": "NONE"
        }
    ]
}
Update file permissions
Code Example
function upadateFilePermissions(dataFileId, data) {
  const url = `/domo/data-files/v1/${dataFileId}/permissions`;
  return domo.put(url, data);
}
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
dataFileId Integer Required The id of the file you wish to update permission details for
HTTP Request
PUT /domo/data-files/v1/{dataFileId}/permissions HTTP/1.1
Accept: application/json
Request Body
The request body accepts a permissions object.
{
    "publicAccess": true,
    "entries": [
        {
            "entityType": "USER",
            "entityId": "1089963280",
            "grant": "READ_WRITE_DELETE_SHARE_ADMIN",
            "pass": "NONE"
        }
    ]
}
HTTP Response
Returns the parameter of success or error based on a valid permission object for the given file Id.
HTTP/1.1 200 OK
Multi-part Files API
The Multi-part Files API allows for efficient upload, update, and management of large files in parts. It uses Domo’s Data File Service, supporting session-based file chunking for fault tolerance and enhanced control.
Creating a Multi-part Upload Session
To begin a multi-part file upload, create an upload session by calling createSession. This will return a session ID that is essential for uploading file parts.
Code Example
export const createSession = async (name, description, contentType) => {
  const url = '/domo/data-files/v1/multipart';
  return await domo.post(url, {
    name,
    description,
    contentType,
    'Cache-Control': 'no-cache',
  });
};
Parameters
name (String): The name of the file.
description (String): A description of the file.
contentType (String): The MIME type of the file.
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
name String Required The name of the file
description String Optional A description of the file
contentType String Required The MIME type of the file
HTTP Request
POST /domo/data-files/v1/multipart HTTP/1.1
Accept: application/json
Request Body
The request body accepts
{
    "name": "SampleFile",
    "description": "Sample Description",
    "contentType": "application/pdf",
    "Cache-Control": "no-cache",
}
HTTP Response
Returns the session ID.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "sessionId": "1234567890"
}
Creating a Multi-part Upload Update Session
To update a multi-part file, create an update session by calling createUpdateSession and passing in the fileId. This will return a session ID that is essential for uploading file parts.
Code Example
export const createUpdateSession = async (
  fileId,
  name,
  description,
  contentType,
) => {
  const url = `/domo/data-files/v1/${fileId}/multipart`;
  return await domo.post(url, {
    fileId,
    name,
    description,
    contentType,
    'Cache-Control': 'no-cache',
  });
};
Parameters
name (String): The name of the file.
description (String): A description of the file.
contentType (String): The MIME type of the file.
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
fileId Long Required The id of the file you wish to update
name String Required The name of the file
description String Optional A description of the file
contentType String Required The MIME type of the file
HTTP Request
POST /domo/data-files/v1/{fileId}/multipart HTTP/1.1
Accept: application/json
Request Body
The request body accepts
{
    "fileId": 401,
    "name": "SampleFile",
    "description": "Sample Description",
    "contentType": "application/pdf",
    "Cache-Control": "no-cache",
}
HTTP Response
Returns the session ID.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "sessionId": "1234567890"
}
Uploading File Parts
After creating a session, upload the file in chunks. Each chunk is sent with a unique index and can optionally include a checksum for verification. The checkSum is used to verify the integrity of the uploaded chunk.
You can determine the chunk size manually, but a good recommended size is between 10MB and 100MB.
export const uploadPart = async (
  sessionId,
  index,
  part,
  contentType,
  checkSum,
) => {
  const url = `/domo/data-files/v1/multipart/${sessionId}/part/${index}${
    checkSum ? `?[checksum=${checkSum}]` : ''
  }`;
  return await domo.put(url, part, { contentType });
};
Parameters
sessionId (String): The session ID from createSession or createUpdateSession.
index (Number): Part number for ordering (1–10,000).
part (ArrayBuffer | String): File data chunk.
contentType (String): The content type of the chunk.
checkSum (String, optional): SHA-256 checksum for the chunk.
Arguments
| Property Name | Type | Required | Description | | ------------- | ----------- | -------- | ------------------------------------------------------------ | --------------- | | sessionId | String | Required | The session ID from createSession or createUpdateSession | | index | Number | Required | Part number for ordering (1–10,000) | | part | ArrayBuffer | String | Required | File data chunk | | contentType | String | Required | The content type of the chunk | | checkSum | String | Optional | SHA-256 checksum for the chunk |
HTTP Request
PUT /domo/data-files/v1/multipart/{sessionId}/part/{index}$?checksum={checkSum} HTTP/1.1
Accept: application/json
Request Body
The request body accepts the file data chunk.
{
    "contentType": "application/pdf",
}
HTTP Response
Returns the session ID.
HTTP/1.1 200 OK
Completing a Multi-part Upload
Once all parts are uploaded, finalize the process with complete:
export const complete = async (sessionId) => {
  const url = `/domo/data-files/v1/multipart/${sessionId}/commit`;
  return await domo.post(url, { sessionId });
};
Parameter
sessionId (String): The session ID to commit.
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
sessionId String Required The session ID to commit
HTTP Request
POST /domo/data-files/v1/multipart/{sessionId}/commit HTTP/1.1
Accept: application/json
Request Body
The request body accepts the file data chunk.
{
    "sessionId": "1234567890"
}
HTTP Response
Returns the session ID.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "dataFileId": "1234567890",
    "revisionId": "1234567890"
}
Error Handling and Retry Mechanism
If a part upload fails, a retry mechanism limits the attempts per chunk, aborting the session after a specified count.
export const abort = async (sessionId) => {
  const url = `/domo/data-files/v1/multipart/${sessionId}/abort`;
  return await domo.post(url);
};
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
sessionId String Required The session ID to abort
HTTP Request
POST /domo/data-files/v1/multipart/{sessionId}/abort HTTP/1.1
Accept: application/json
HTTP Response
Returns the session ID.
HTTP/1.1 200 OK
Files API
Upload a file
Request Body
HTTP Response
Upload a file revision
Get all files metadata
Get file metadata by ID
Download a file
Delete a file
Get file permissions
Update file permissions
Creating a Multi-part Upload Session
Creating a Multi-part Upload Update Session
Uploading File Parts
Completing a Multi-part Upload
Error Handling and Retry Mechanism

FileSet API (BETA)
This API reference documents the endpoints for managing FileSets and Files in Domo from within a Domo app.
BETA: This API is currently in BETA and is subject to change. Endpoints, request/response formats, and functionality may change without notice. Note: All code examples below are tested and match the working Domo app UI. Use domo.* methods for all API calls except File upload/download, which require fetch for binary or FormData support.
Get File by Path
Method: GET
Endpoint: /domo/files/v1/filesets/{filesetId}/path?path={filePath}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
path String Yes The path to the File within the FileSet
Javascript (domo.get)
Javascript (fetch)
domo
  .get(
    `/domo/files/v1/filesets/${filesetId}/path?path=${encodeURIComponent(
      filePath,
    )}`,
  )
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000001",
  "path": "rules.txt",
  "name": "rules.txt",
  "fileType": "TEXT",
  "contentType": "text/plain",
  "size": 12345,
  "hash": "fakehash00000000000000000000000000000000000000000000000000000000000001",
  "hashAlgorithm": "SHA_256_HEX",
  "downloadUrl": null,
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111,
  "connectorKey": null,
  "indexStatus": null,
  "indexReason": null
}
Get File by Id
Method: GET
Endpoint: /domo/files/v1/filesets/{filesetId}/files/{fileId}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
fileId String Yes The ID of the File
Javascript (domo.get)
Javascript (fetch)
domo
  .get(`/domo/files/v1/filesets/${filesetId}/files/${fileId}`)
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000002",
  "path": "rules.txt",
  "name": "rules.txt",
  "fileType": "TEXT",
  "contentType": "text/plain",
  "size": 12345,
  "hash": "fakehash00000000000000000000000000000000000000000000000000000000000002",
  "hashAlgorithm": "SHA_256_HEX",
  "downloadUrl": "/domo/files/v1/filesets/00000000-0000-0000-0000-000000000010/files/00000000-0000-0000-0000-000000000002/download",
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111,
  "connectorKey": null,
  "indexStatus": null,
  "indexReason": null
}
Download File by Id
Method: GET
Endpoint: /domo/files/v1/filesets/{filesetId}/files/{fileId}/download
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
fileId String Yes The ID of the File
Note: Use fetch for File downloads. domo.get does not support binary downloads.
Javascript (fetch)
fetch(`/domo/files/v1/filesets/${filesetId}/files/${fileId}/download`)
  .then((response) => response.blob())
  .then((blob) => {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'downloaded-file'; // Set your filename
    document.body.appendChild(a);
    a.click();
    a.remove();
    window.URL.revokeObjectURL(url);
  })
  .catch((error) => console.error(`Error: ${error}`));
Response:
Returns the File contents as a download (binary/text stream).
Query Files
Method: POST
Endpoint: /domo/files/v1/filesets/{filesetId}/query
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Request Body Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
query String Yes Text to search for in Files
directoryPath String No Limit search to a specific directory
topK Integer No Maximum number of results to return
Javascript (domo.post)
Javascript (fetch)
domo
  .post(`/domo/files/v1/filesets/${filesetId}/query`, {
    query: 'search for text in documents', // Required: Text to search for in files
    directoryPath: 'reports/quarterly', // Optional: Limit search to specific directory
    topK: 5, // Optional: Maximum number of results to return
  })
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
[
  {
    "id": "00000000-0000-0000-0000-000000000003",
    "path": "rules.txt",
    "name": "rules.txt",
    "fileType": "TEXT",
    "contentType": "text/plain",
    "size": 12345,
    "created": "2025-01-01T00:00:00.000Z",
    "createdBy": 111111111
  }
]
Upload File
Method: POST
Endpoint: /domo/files/v1/filesets/{filesetId}/files
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Note: Use fetch for file uploads. Always set the file content type to text/plain for text files, as in the app code.
Javascript (fetch)
const file = fileInput.files[0];
const formdata = new FormData();
formdata.append(
  'file',
  new File([file], file.name, { type: 'text/plain' }),
  file.name,
);
formdata.append('createFileRequest', JSON.stringify({ directoryPath: '' }));
fetch(`/domo/files/v1/filesets/${filesetId}/files`, {
  method: 'POST',
  body: formdata,
})
  .then((response) => response.json())
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000004",
  "path": "rules.txt",
  "name": "rules.txt",
  "fileType": "TEXT",
  "contentType": "text/plain",
  "size": 12345,
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111
}
Search Files in FileSet
Method: POST
Endpoint: /domo/files/v1/filesets/{filesetId}/files/search
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Query Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
directoryPath String No Filter Files by specific directory path
immediateChildren Boolean No If true, returns only immediate children of directory (default: false)
limit Integer No Maximum number of results (default: 100)
next String No Pagination token for fetching next set of results
Request Body Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
fieldSort Array No Sort options for results. Array of FieldSort Objects.
filters Array No Filter criteria for the search. Array of Filter Objects.
dateFilters Array No Date-based filter criteria. Array of DateFilter Objects.
Filter Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name to filter on (e.g., 'name', 'description')
value Array Values to match against
not Boolean If true, inverts the filter match
operator String Operation type: 'EQUALS', 'GREATER_THAN', 'LESS_THAN', 'IN', 'LIKE', etc.
FieldSort Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name to sort by
order String Sort direction: 'ASC' or 'DESC'
DateFilter Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name for date filter (e.g., 'created')
start String Start timestamp as ISO string
end String End timestamp as ISO string
not Boolean If true, inverts the date filter match
Javascript (domo.post)
Javascript (fetch)
// Example 1: List all files
domo
  .post(`/domo/files/v1/filesets/${filesetId}/files/search`, {})
  .then((result) => console.log(result.files))
  .catch((error) => console.error(`Error: ${error}`));
// Example 2: Advanced search with directory path and filters
domo
  .post(
    `/domo/files/v1/filesets/${filesetId}/files/search?directoryPath=reports&limit=20`,
    {
      // Sort by file name in ascending order
      fieldSort: [
        {
          field: 'name',
          order: 'ASC',
        },
      ],
      // Filter files by name
      filters: [
        {
          field: 'name',
          value: ['.pdf'],
          operator: 'LIKE',
        },
      ],
      // Filter files created in past 30 days
      dateFilters: [
        {
          field: 'created',
          start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days ago as ISO string
          end: new Date().toISOString(), // Current time as ISO string
        },
      ],
    },
  )
  .then((result) => console.log(result.files))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "files": [
    {
      "id": "00000000-0000-0000-0000-000000000005",
      "path": "reports/quarterly-report.pdf",
      "name": "quarterly-report.pdf",
      "fileType": "FILE",
      "contentType": "application/pdf",
      "size": 234567,
      "created": "2025-06-15T00:00:00.000Z",
      "createdBy": 111111111
    }
  ],
  "pageContext": {
    "next": "eyJpZCI6IjEyMzQ1Njc4OTAifQ=="
  }
}
Delete Files by Path
Method: DELETE
Endpoint: /domo/files/v1/filesets/{filesetId}/path?path={filePath}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
filePath String Yes The path to the File within the FileSet
Javascript (domo.delete)
Javascript (fetch)
domo
  .delete(
    `/domo/files/v1/filesets/${filesetId}/path?path=${encodeURIComponent(
      filePath,
    )}`,
  )
  .then((result) => {
    if (result === 1 || (result && result.status === 'success')) {
      console.log('File deleted successfully.');
    } else {
      console.log(result);
    }
  })
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "status": "success",
  "message": "File deleted successfully."
}
Delete File by Id
Method: DELETE
Endpoint: /domo/files/v1/filesets/{filesetId}/files/{fileId}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
fileId String Yes The ID of the File
Javascript (domo.delete)
Javascript (fetch)
domo
  .delete(`/domo/files/v1/filesets/${filesetId}/files/${fileId}`)
  .then((result) => {
    if (result === 1 || (result && result.status === 'success')) {
      console.log('File deleted successfully.');
    } else {
      console.log(result);
    }
  })
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "status": "success",
  "message": "File deleted successfully."
}
Search FileSets
Method: POST
Endpoint: /domo/files/v1/filesets/search
Query Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
limit Integer No Maximum number of results (default: 100)
offset Integer No Pagination offset (default: 0)
Note: To list all FileSets, send an empty object as the body. To filter, provide filter parameters in the body.
Request Body Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
fieldSort Array No Sort options for results. Array of FieldSort Objects.
filters Array No Filter criteria for the search. Array of Filter Objects.
dateFilters Array No Date-based filter criteria. Array of DateFilter Objects.
Filter Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name to filter on (e.g., 'name', 'description')
value Array Values to match against
not Boolean If true, inverts the filter match
operator String Operation type: 'EQUALS', 'GREATER_THAN', 'LESS_THAN', 'IN', 'LIKE', etc.
FieldSort Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name to sort by
order String Sort direction: 'ASC' or 'DESC'
DateFilter Object Properties:
PROPERTY TYPE DESCRIPTION
field String Field name for date filter (e.g., 'created')
start String Start timestamp as ISO string
end String End timestamp as ISO string
not Boolean If true, inverts the date filter match
Javascript (domo.post)
Javascript (fetch)
// Example 1: List all FileSets (empty search)
domo
  .post('/domo/files/v1/filesets/search', {})
  .then((result) => console.log(result.fileSets))
  .catch((error) => console.error(`Error: ${error}`));
// Example 2: Advanced search with filters and sorting
domo
  .post('/domo/files/v1/filesets/search', {
    // Sort by name in ascending order
    fieldSort: [
      {
        field: 'name',
        order: 'ASC',
      },
    ],
    // Filter FileSet by name containing "Marketing"
    filters: [
      {
        field: 'name',
        value: ['Marketing'],
        operator: 'LIKE',
      },
    ],
    // Filter FileSet created between two dates
    dateFilters: [
      {
        field: 'created',
        start: '2025-06-01T19:23:55.156Z', // June 1, 2024
        end: '2025-06-30T19:23:55.156Z', // June 30, 2024
      },
    ],
  })
  .then((result) => console.log(result.fileSets))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "fileSets": [
    {
      "id": "00000000-0000-0000-0000-000000000010",
      "name": "Sample FileSet",
      "description": "A sample FileSet for demonstration purposes.",
      "created": "2025-01-01T00:00:00.000Z",
      "createdBy": 111111111
    }
  ]
}
Create FileSet
Method: POST
Endpoint: /domo/files/v1/filesets
Request Body Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
name String Yes The name of the FileSet
accountId Integer No The account ID to associate (nullable)
connectorContext Object No Connector context for the FileSet (nullable). ConnectorContext Object.
description String No Description for the FileSet
ConnectorContext Object Properties:
PROPERTY TYPE REQUIRED DESCRIPTION
connector String Yes The connector key
relativePath String No Relative path for the connector (nullable)
Javascript (domo.post)
Javascript (fetch)
domo
  .post('/domo/files/v1/filesets', {
    name: 'Sample FileSet',
    description: 'A sample FileSet for demonstration purposes.',
    // accountId: 12345, // Optional
    // connectorContext: { connector: 'S3', relativePath: 'bucket/path' }, // Optional
  })
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000012",
  "name": "Sample FileSet",
  "description": "A sample FileSet for demonstration purposes.",
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111
}
Get FileSet by Id
Method: GET Endpoint: /domo/files/v1/filesets/{filesetId}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Javascript (domo.get)
Javascript (fetch)
domo
  .get(`/domo/files/v1/filesets/${filesetId}`)
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000013",
  "name": "Sample FileSet",
  "description": "A sample FileSet for demonstration purposes.",
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111
}
Update FileSet by Id
Method: POST
Endpoint: /domo/files/v1/filesets/{filesetId}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Request Body Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
name String No The new name for the FileSet
description String No The new description for the FileSet
Javascript (domo.post)
Javascript (fetch)
domo
  .post(`/domo/files/v1/filesets/${filesetId}`, {
    name: 'Updated FileSet Name', // Optional: New name for the FileSet
    description: 'Updated description.', // Optional: New description
  })
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "id": "00000000-0000-0000-0000-000000000014",
  "name": "Sample FileSet",
  "description": "A sample FileSet for demonstration purposes.",
  "created": "2025-01-01T00:00:00.000Z",
  "createdBy": 111111111
}
Delete FileSet by Id
Method: DELETE
Endpoint: /domo/files/v1/filesets/{filesetId}
Path Parameters:
PARAMETER TYPE REQUIRED DESCRIPTION
filesetId String Yes The ID of the FileSet
Javascript (domo.delete)
Javascript (fetch)
domo
  .delete(`/domo/files/v1/filesets/${filesetId}`)
  .then((result) => console.log(result))
  .catch((error) => console.error(`Error: ${error}`));
Response:
{
  "status": "success",
  "message": "FileSet deleted successfully."
}
FileSet API (BETA)
Get File by Path
Get File by Id
Download File by Id
Query Files
Upload File
Search Files in FileSet
Delete Files by Path
Delete File by Id
Search FileSets
Create FileSet
Get FileSet by Id
Update FileSet by Id
Delete FileSet by Id

Groups API
The Groups API is a Read Only set of endpoints available to retrieve information about the various groups that belong to the instance in which a Custom App is published. This enables your application to take advantage of knowing the groups that individual users could potentially belong to and alter their user experience accordingly.
All Groups
Retrieve a list of details for all groups of an instance.
Code Example
domo.get(`/domo/groups/v1`)
   .then(data => console.log(data))
HTTP Request
GET /domo/groups/v1
Content-Type: application/json
Accept: application/json
HTTP Response
HTTP/1.1 200 OK
[
    {
        "id": 1051417,
        "name": "New Users",
        "type": "adHoc",
        "userIds": [],
        "created": "2018-10-03T23:26:04.000+0000",
        "memberCount": 15210,
        "active": true,
        "default": true
    },
    {
        "id": 1085275,
        "name": "Power Users",
        "type": "directory",
        "userIds": [],
        "created": "2018-11-15T15:21:27.000+0000",
        "memberCount": 2265,
        "active": true,
        "default": false
    }
]
Group by Id
Retrieve the details for an individual group given its Id.
Code Example
domo.get(`/domo/groups/v1/1051417`)
    .then(data => console.log(data))
HTTP Request
GET /domo/groups/v1/{groupId}
Content-Type: application/json
Accept: application/json
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
groupId Long Required The ID of the desired group
HTTP Response
HTTP/1.1 200 OK
{
    "id": 1051417,
    "name": "New Users",
    "type": "adHoc",
    "userIds": [],
    "created": "2018-10-03T23:26:04.000+0000",
    "memberCount": 15210,
    "active": true,
    "default": true
}
Group by Name
Retrieve the details for an individual group given its name.
Code Example
domo.get(`/domo/groups/v1/name?groupName=New Users`)
    .then(data => console.log(data))
HTTP Request
GET /domo/groups/v1/name?groupName={groupName}
Content-Type: application/json
Accept: application/json
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
groupName String Required The name of the desired group
HTTP Response
HTTP/1.1 200 OK
{
    "id": 1051417,
    "name": "New Users",
    "type": "adHoc",
    "userIds": [],
    "created": "2018-10-03T23:26:04.000+0000",
    "memberCount": 15210,
    "active": true,
    "default": true
}
Groups by User
Retrieve the details for an all groups that an individual user belongs to, given a user Id. You can obtain the user Id of the current user using the domo object (provided via the domo.js javascript file that is included with all apps initialized by the Domo Apps CLI) as demonstrated in the code example below.
Code Example
domo.get(`/domo/groups/v1/user/${domo.env.userId}`)
    .then(data => console.log(data))
HTTP Request
GET /domo/groups/v1/user/{userId}
Content-Type: application/json
Accept: application/json
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
userId Long Required The id of the desired user
HTTP Response
HTTP/1.1 200 OK
[
    {
        "id": 1051417,
        "name": "New Users",
        "type": "adHoc",
        "userIds": [],
        "created": "2018-10-03T23:26:04.000+0000",
        "memberCount": 15210,
        "active": true,
        "default": true
    },
    {
        "id": 1085275,
        "name": "Power Users",
        "type": "directory",
        "userIds": [],
        "created": "2018-11-15T15:21:27.000+0000",
        "memberCount": 2265,
        "active": true,
        "default": false
    }
]
Groups API
All Groups
Group by Id
Group by Name
Groups by User

User API
All Users
Information for all users can be retrieved using the following endpoint:
GET /domo/users/v1?includeDetails={true|false}&limit={int}&offset={int}
Details
includeDetails: Include all user information
limit: The number of user records to return
offset: Get users starting with this offset in the list of users
returns (includeDetails=false)
[
 {
     "id": 1,
     "displayName": "User One",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
     "role": "Admin"
 },
 {
     "id": 3,
     "displayName": "User Two",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/510BB31EE19FDDBA8046F18ACD3C5D.jpg",
     "role": "Privileged"
 },
...
]
returns (includeDetails=true)
[
 {
     "id": 1,
     "displayName": "User One",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
     "role": "Admin",
     "detail": {
        "title": "",
        "email": "userone@domo.com",
        "phoneNumber": "",
        "employeeNumber": 1,
        "pending": false
    }
 },
 {
     "id": 2,
     "displayName": "User Two",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/510BB31EE19FDDBA8046F18ACD3C5D.jpg",
     "role": "Privileged",
     "detail": {
        "title": "",
        "email": "usertwo@domo.com",
        "phoneNumber": "",
        "employeeNumber": 2,
        "pending": false
    }
 },
...
]
Single User
Information for a single user can be retrieved using the following endpoint:
GET /domo/users/v1/:userId?includeDetails={true|false}
Details
userId: The id (long) of the desired user. Note: The current user Id is supplied via by the domo.js library as part of the domo.env object
includeDetails: Include all user information
returns (includeDetails=false)
{
  "id": 1,
  "displayName": "User One",
  "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
  "role": "Admin"
}
returns (includeDetails=true)
{
  "id": 1,
  "displayName": "User One",
  "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
  "role": "Admin",
  "detail": {
    "title": "",
    "email": "userone@domo.com",
    "phoneNumber": "",
    "employeeNumber": 1,
    "pending": false
  }
}
User Avatar
User avatars are available at the avatars endpoint
GET /domo/avatars/v2/{entityType}/{entityId}?size={size}&defaultForeground={color}&defaultBackground={color}&defaultText={text}
Valid sizes (pixels)
100: 100 X 100
300: 300 X 300
HTTP Request
GET /domo/avatars/v2/USER/846578099?size=300&defaultForeground=fff&defaultBackground=000&defaultText=D
Code Example
<img
  src="/domo/avatars/v2/USER/846578099?size=300&defaultForeground=fff&defaultBackground=000&defaultText=D"
  alt="User Avatar"
/>
User API
All Users
Single User
User Avatar

User API
All Users
Information for all users can be retrieved using the following endpoint:
GET /domo/users/v1?includeDetails={true|false}&limit={int}&offset={int}
Details
includeDetails: Include all user information
limit: The number of user records to return
offset: Get users starting with this offset in the list of users
returns (includeDetails=false)
[
 {
     "id": 1,
     "displayName": "User One",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
     "role": "Admin"
 },
 {
     "id": 3,
     "displayName": "User Two",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/510BB31EE19FDDBA8046F18ACD3C5D.jpg",
     "role": "Privileged"
 },
...
]
returns (includeDetails=true)
[
 {
     "id": 1,
     "displayName": "User One",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
     "role": "Admin",
     "detail": {
        "title": "",
        "email": "userone@domo.com",
        "phoneNumber": "",
        "employeeNumber": 1,
        "pending": false
    }
 },
 {
     "id": 2,
     "displayName": "User Two",
     "avatarKey": "/domo/avatars/v1/avatars/dev/86/510BB31EE19FDDBA8046F18ACD3C5D.jpg",
     "role": "Privileged",
     "detail": {
        "title": "",
        "email": "usertwo@domo.com",
        "phoneNumber": "",
        "employeeNumber": 2,
        "pending": false
    }
 },
...
]
Single User
Information for a single user can be retrieved using the following endpoint:
GET /domo/users/v1/:userId?includeDetails={true|false}
Details
userId: The id (long) of the desired user. Note: The current user Id is supplied via by the domo.js library as part of the domo.env object
includeDetails: Include all user information
returns (includeDetails=false)
{
  "id": 1,
  "displayName": "User One",
  "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
  "role": "Admin"
}
returns (includeDetails=true)
{
  "id": 1,
  "displayName": "User One",
  "avatarKey": "/domo/avatars/v1/avatars/dev/86/420BB31EE19FDDBA8096F19ACD4C4D.jpg",
  "role": "Admin",
  "detail": {
    "title": "",
    "email": "userone@domo.com",
    "phoneNumber": "",
    "employeeNumber": 1,
    "pending": false
  }
}
User Avatar
User avatars are available at the avatars endpoint
GET /domo/avatars/v2/{entityType}/{entityId}?size={size}&defaultForeground={color}&defaultBackground={color}&defaultText={text}
Valid sizes (pixels)
100: 100 X 100
300: 300 X 300
HTTP Request
GET /domo/avatars/v2/USER/846578099?size=300&defaultForeground=fff&defaultBackground=000&defaultText=D
Code Example
<img
  src="/domo/avatars/v2/USER/846578099?size=300&defaultForeground=fff&defaultBackground=000&defaultText=D"
  alt="User Avatar"
/>
User API
All Users
Single User
User Avatar

Workflows API
Domo Workflows allows you to graphically model a business process into an executable workflow using Business Process Management (BPM) notations and flows. Orchestration capabilities offer robust solutions for integrating internal and external systems, configuring decision logic, and automating activities in a workflow.
For more background on Workflows, check out the Knowledge Base for an overview.
If you haven't leveraged Workflows from within Apps before, checkout the guide on hitting a Workflow from an App, which details how to configure your manifest.json file and wire up Workflows to your app.
Start a Workflow
Starts a Workflow and returns details about the Workflow Instance.
Code Example
const startWorkflow = async (workflowAlias, body) => {
  const instance = await domo.post(
    `/domo/workflow/v1/models/${workflowAlias}/start`,
    body
  );
  return instance;
};
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
workflowAlias String Required The name given to the Workflow in the manifest
HTTP Request
POST /domo/workflow/v1/models/{workflowAlias}/start
Request Body
The request body accepts an object containing the start parameters required to run the workflow. These parameters are also defined in the manifest.json file and properties in the object should correspond to the aliasName of the parameter.
{"parameter1": parameter1, "parameter2": parameter2}
HTTP Response
Returns the information about the instance of the Workflow that was just started. The status property can take the values null, IN_PROGRESS, CANCELED, or COMPLETED.
A status of null might be valid. It just means the workflow hasn’t reported back as started yet.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "2052e10a-d142-4391-a731-2be1ab1c0188", // id of the workflow
    "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138", // id of the workflow instance
    "modelName": "AddTwoNumbers", // name of the workflow
    "modelVersion": "1.1.0", // workflow version number
    "createdBy": "8811501", // user id of workflow creator
    "createdOn": "2023-11-15T15:28:57.479Z",
    "updatedBy": "8811501",
    "updatedOn": "2023-11-15T15:28:57.479Z",
    "status": "null"
}
Get Metrics for a Workflow
Returns key metric information about a Workflow.
Code Example
const getWorkflowMetrics = async (workflowAliasedName) => {
  const metrics = await domo.get(
    `/domo/workflow/v1/models/${workflowAliasedName}/overall`
  );
  return metrics;
};
Arguments (query parameters)
PROPERTY NAME TYPE REQUIRED DESCRIPTION
limit Long Optional limit of instance metrics returns
offset Long Optional offset for pagination
after Long Optional after a certain time
until Long Optional before a certain time
status String Optional Only show instances that have the provided status(es) IN_PROGRESS, CANCELED, COMPLETED
HTTP Request
GET /domo/workflow/v1/models/{workflowAliasedName}/overall
HTTP Response
Returns the information about the instance of the Workflow that was just started. The status property can take the values null, IN_PROGRESS, CANCELED, or COMPLETED.
A status of null might be valid. It just means the workflow hasn’t reported back as started yet.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
    "version": "1.1.0",
    "completedWorkflows": 0,
    "inProgressWorkflows": 4,
    "failedWorkflows": 1,
    "canceledWorkflows": 0,
    "averageCycleTime": 0,
    "instanceMetric": [
        {
            "instanceId": "2052e10a-d142-4391-a731-2be1ab1c0188",
            "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
            "version": "1.1.0",
            "creatorId": "8811501",
            "workflowStartTime": "2023-11-15T15:28:57.522Z",
            "workflowEndTime": null,
            "workflowCancelTime": null,
            "workflowCycleTime": 0,
            "status": "IN_PROGRESS"
        },
        {
            "instanceId": "e5cb6377-36b5-4277-a2dd-2bac9a6a2d5d",
            "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
            "version": "1.1.0",
            "creatorId": "8811501",
            "workflowStartTime": "2023-12-11T16:20:18.900Z",
            "workflowEndTime": null,
            "workflowCancelTime": null,
            "workflowCycleTime": 0,
            "status": "IN_PROGRESS"
        },
        {
            "instanceId": "0dee93c0-0bdf-442c-83f6-dc294aa577e1",
            "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
            "version": "1.1.0",
            "creatorId": "8811501",
            "workflowStartTime": "2023-12-11T16:19:49.956Z",
            "workflowEndTime": null,
            "workflowCancelTime": null,
            "workflowCycleTime": 0,
            "status": "IN_PROGRESS"
        },
        {
            "instanceId": "10d6138b-c814-406d-9ea0-99646d0bf467",
            "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
            "version": "1.1.0",
            "creatorId": "8811501",
            "workflowStartTime": "2023-12-11T16:20:33.930Z",
            "workflowEndTime": null,
            "workflowCancelTime": null,
            "workflowCycleTime": 0,
            "status": "IN_PROGRESS"
        },
        {
            "instanceId": "0acfc3c9-c3e8-420d-81a5-6d27f17c0bdf",
            "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138",
            "version": "1.1.0",
            "creatorId": "8811501",
            "workflowStartTime": "2023-11-15T15:28:59.950Z",
            "workflowEndTime": null,
            "workflowCancelTime": null,
            "workflowCycleTime": 0,
            "status": "FAILED"
        }
    ]
}
Get Workflow Instance
If you are checking on the status of an existing Workflow instance.
Code Example
const getWorkflowInstance = async (workflowAlias, workflowInstanceId) => {
  const instance = await domo.get(
    `/domo/workflow/v1/models/${workflowAlias}/instance/${workflowInstanceId}`
  );
  return instance;
};
Arguments
PROPERTY NAME TYPE REQUIRED DESCRIPTION
workflowAlias String Required The name given to the Workflow in the manifest
workflowInstanceId String Required The UUID of the Workflow instance
HTTP Request
GET /domo/workflow/v1/models/{workflowAlias}/instance/{workflowInstanceId}
HTTP Response
Returns the information about the instance of the Workflow requested. The status property can take the values null, IN_PROGRESS, CANCELED, or COMPLETED.
A status of null might be valid. It just means the workflow hasn’t reported back as started yet.
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "id": "2052e10a-d142-4391-a731-2be1ab1c0188", // id of the workflow
    "modelId": "a8afdc89-9491-4ee4-b7c3-b9e9b86c0138", // id of the workflow instance
    "modelName": "AddTwoNumbers", // name of the workflow
    "modelVersion": "1.1.0", // workflow version number
    "createdBy": "8811501", // user id of workflow creator
    "createdOn": "2023-11-15T15:28:57.479Z",
    "updatedBy": "8811501",
    "updatedOn": "2023-11-15T15:28:57.479Z",
    "status": "COMPLETED"
}
Workflows API
Start a Workflow
Get Metrics for a Workflow
Get Workflow Instance

